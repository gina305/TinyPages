// src/result.ts
function Err(error, errorExtras) {
  return { ok: false, error, errorExtras };
}
function Ok(value) {
  return { ok: true, value };
}

// src/request/getToken.ts
import { exec } from "child_process";
var isDeployment = Boolean(process.env.REPLIT_DEPLOYMENT);
async function genReplIdentityToken() {
  return new Promise((resolve, reject) => {
    exec(
      '$REPLIT_CLI identity create -audience="modelfarm@replit.com"',
      (error, stdout, stderr) => {
        if (error) {
          reject(`Getting identity token: ${error.name} ${error.message}`);
          return;
        }
        if (stderr) {
          reject(`Saw stderr getting identity token: ${stderr}`);
          return;
        }
        resolve(stdout.trim());
      }
    );
  });
}
async function getDeploymentToken() {
  const res = await fetch("http://localhost:1105/getIdentityToken", {
    body: JSON.stringify({ audience: "modelfarm@replit.com" }),
    headers: {
      "Content-Type": "application/json"
    },
    method: "POST"
  });
  const json = await res.json();
  if (!json) {
    throw new Error("Expected json to have identity token");
  }
  if (typeof json !== "object") {
    throw new Error("Expected json to be an object");
  }
  if (!("identityToken" in json)) {
    throw new Error("Expected json to have identity token");
  }
  if (typeof json.identityToken !== "string") {
    throw new Error("Expected identity token to be a string");
  }
  return json.identityToken;
}
var cachedToken = null;
function resetTokenSoon() {
  setTimeout(() => {
    cachedToken = null;
  }, 1e3 * 30);
}
async function getToken() {
  if (!cachedToken) {
    const fn = isDeployment ? getDeploymentToken : genReplIdentityToken;
    cachedToken = await fn();
    resetTokenSoon();
  }
  return cachedToken;
}

// node_modules/p-defer/index.js
function pDefer() {
  const deferred = {};
  deferred.promise = new Promise((resolve, reject) => {
    deferred.resolve = resolve;
    deferred.reject = reject;
  });
  return deferred;
}

// node_modules/it-pushable/dist/src/fifo.js
var FixedFIFO = class {
  buffer;
  mask;
  top;
  btm;
  next;
  constructor(hwm) {
    if (!(hwm > 0) || (hwm - 1 & hwm) !== 0) {
      throw new Error("Max size for a FixedFIFO should be a power of two");
    }
    this.buffer = new Array(hwm);
    this.mask = hwm - 1;
    this.top = 0;
    this.btm = 0;
    this.next = null;
  }
  push(data) {
    if (this.buffer[this.top] !== void 0) {
      return false;
    }
    this.buffer[this.top] = data;
    this.top = this.top + 1 & this.mask;
    return true;
  }
  shift() {
    const last = this.buffer[this.btm];
    if (last === void 0) {
      return void 0;
    }
    this.buffer[this.btm] = void 0;
    this.btm = this.btm + 1 & this.mask;
    return last;
  }
  isEmpty() {
    return this.buffer[this.btm] === void 0;
  }
};
var FIFO = class {
  size;
  hwm;
  head;
  tail;
  constructor(options = {}) {
    this.hwm = options.splitLimit ?? 16;
    this.head = new FixedFIFO(this.hwm);
    this.tail = this.head;
    this.size = 0;
  }
  calculateSize(obj) {
    if (obj?.byteLength != null) {
      return obj.byteLength;
    }
    return 1;
  }
  push(val) {
    if (val?.value != null) {
      this.size += this.calculateSize(val.value);
    }
    if (!this.head.push(val)) {
      const prev = this.head;
      this.head = prev.next = new FixedFIFO(2 * this.head.buffer.length);
      this.head.push(val);
    }
  }
  shift() {
    let val = this.tail.shift();
    if (val === void 0 && this.tail.next != null) {
      const next = this.tail.next;
      this.tail.next = null;
      this.tail = next;
      val = this.tail.shift();
    }
    if (val?.value != null) {
      this.size -= this.calculateSize(val.value);
    }
    return val;
  }
  isEmpty() {
    return this.head.isEmpty();
  }
};

// node_modules/it-pushable/dist/src/index.js
var AbortError = class extends Error {
  type;
  code;
  constructor(message, code) {
    super(message ?? "The operation was aborted");
    this.type = "aborted";
    this.code = code ?? "ABORT_ERR";
  }
};
function pushable(options = {}) {
  const getNext = (buffer) => {
    const next = buffer.shift();
    if (next == null) {
      return { done: true };
    }
    if (next.error != null) {
      throw next.error;
    }
    return {
      done: next.done === true,
      // @ts-expect-error if done is false, value will be present
      value: next.value
    };
  };
  return _pushable(getNext, options);
}
function _pushable(getNext, options) {
  options = options ?? {};
  let onEnd = options.onEnd;
  let buffer = new FIFO();
  let pushable2;
  let onNext;
  let ended;
  let drain = pDefer();
  const waitNext = async () => {
    try {
      if (!buffer.isEmpty()) {
        return getNext(buffer);
      }
      if (ended) {
        return { done: true };
      }
      return await new Promise((resolve, reject) => {
        onNext = (next) => {
          onNext = null;
          buffer.push(next);
          try {
            resolve(getNext(buffer));
          } catch (err) {
            reject(err);
          }
          return pushable2;
        };
      });
    } finally {
      if (buffer.isEmpty()) {
        queueMicrotask(() => {
          drain.resolve();
          drain = pDefer();
        });
      }
    }
  };
  const bufferNext = (next) => {
    if (onNext != null) {
      return onNext(next);
    }
    buffer.push(next);
    return pushable2;
  };
  const bufferError = (err) => {
    buffer = new FIFO();
    if (onNext != null) {
      return onNext({ error: err });
    }
    buffer.push({ error: err });
    return pushable2;
  };
  const push = (value) => {
    if (ended) {
      return pushable2;
    }
    if (options?.objectMode !== true && value?.byteLength == null) {
      throw new Error("objectMode was not true but tried to push non-Uint8Array value");
    }
    return bufferNext({ done: false, value });
  };
  const end = (err) => {
    if (ended)
      return pushable2;
    ended = true;
    return err != null ? bufferError(err) : bufferNext({ done: true });
  };
  const _return = () => {
    buffer = new FIFO();
    end();
    return { done: true };
  };
  const _throw = (err) => {
    end(err);
    return { done: true };
  };
  pushable2 = {
    [Symbol.asyncIterator]() {
      return this;
    },
    next: waitNext,
    return: _return,
    throw: _throw,
    push,
    end,
    get readableLength() {
      return buffer.size;
    },
    onEmpty: async (options2) => {
      const signal = options2?.signal;
      signal?.throwIfAborted();
      if (buffer.isEmpty()) {
        return;
      }
      let cancel;
      let listener;
      if (signal != null) {
        cancel = new Promise((resolve, reject) => {
          listener = () => {
            reject(new AbortError());
          };
          signal.addEventListener("abort", listener);
        });
      }
      try {
        await Promise.race([
          drain.promise,
          cancel
        ]);
      } finally {
        if (listener != null && signal != null) {
          signal?.removeEventListener("abort", listener);
        }
      }
    }
  };
  if (onEnd == null) {
    return pushable2;
  }
  const _pushable2 = pushable2;
  pushable2 = {
    [Symbol.asyncIterator]() {
      return this;
    },
    next() {
      return _pushable2.next();
    },
    throw(err) {
      _pushable2.throw(err);
      if (onEnd != null) {
        onEnd(err);
        onEnd = void 0;
      }
      return { done: true };
    },
    return() {
      _pushable2.return();
      if (onEnd != null) {
        onEnd();
        onEnd = void 0;
      }
      return { done: true };
    },
    push,
    end(err) {
      _pushable2.end(err);
      if (onEnd != null) {
        onEnd(err);
        onEnd = void 0;
      }
      return pushable2;
    },
    get readableLength() {
      return _pushable2.readableLength;
    }
  };
  return pushable2;
}

// node_modules/it-merge/dist/src/index.js
function isAsyncIterable(thing) {
  return thing[Symbol.asyncIterator] != null;
}
function merge(...sources) {
  const syncSources = [];
  for (const source of sources) {
    if (!isAsyncIterable(source)) {
      syncSources.push(source);
    }
  }
  if (syncSources.length === sources.length) {
    return function* () {
      for (const source of syncSources) {
        yield* source;
      }
    }();
  }
  return async function* () {
    const output = pushable({
      objectMode: true
    });
    void Promise.resolve().then(async () => {
      try {
        await Promise.all(sources.map(async (source) => {
          for await (const item of source) {
            output.push(item);
          }
        }));
        output.end();
      } catch (err) {
        output.end(err);
      }
    });
    yield* output;
  }();
}
var src_default = merge;

// node_modules/it-pipe/dist/src/index.js
function pipe(first, ...rest) {
  if (first == null) {
    throw new Error("Empty pipeline");
  }
  if (isDuplex(first)) {
    const duplex = first;
    first = () => duplex.source;
  } else if (isIterable(first) || isAsyncIterable2(first)) {
    const source = first;
    first = () => source;
  }
  const fns = [first, ...rest];
  if (fns.length > 1) {
    if (isDuplex(fns[fns.length - 1])) {
      fns[fns.length - 1] = fns[fns.length - 1].sink;
    }
  }
  if (fns.length > 2) {
    for (let i = 1; i < fns.length - 1; i++) {
      if (isDuplex(fns[i])) {
        fns[i] = duplexPipelineFn(fns[i]);
      }
    }
  }
  return rawPipe(...fns);
}
var rawPipe = (...fns) => {
  let res;
  while (fns.length > 0) {
    res = fns.shift()(res);
  }
  return res;
};
var isAsyncIterable2 = (obj) => {
  return obj?.[Symbol.asyncIterator] != null;
};
var isIterable = (obj) => {
  return obj?.[Symbol.iterator] != null;
};
var isDuplex = (obj) => {
  if (obj == null) {
    return false;
  }
  return obj.sink != null && obj.source != null;
};
var duplexPipelineFn = (duplex) => {
  return (source) => {
    const p = duplex.sink(source);
    if (p?.then != null) {
      const stream = pushable({
        objectMode: true
      });
      p.then(() => {
        stream.end();
      }, (err) => {
        stream.end(err);
      });
      let sourceWrap;
      const source2 = duplex.source;
      if (isAsyncIterable2(source2)) {
        sourceWrap = async function* () {
          yield* source2;
          stream.end();
        };
      } else if (isIterable(source2)) {
        sourceWrap = function* () {
          yield* source2;
          stream.end();
        };
      } else {
        throw new Error("Unknown duplex source type - must be Iterable or AsyncIterable");
      }
      return src_default(stream, sourceWrap());
    }
    return duplex.source;
  };
};

// node_modules/browser-readablestream-to-it/dist/src/index.js
async function* browserReadableStreamToIt(stream, options = {}) {
  const reader = stream.getReader();
  try {
    while (true) {
      const result = await reader.read();
      if (result.done) {
        return;
      }
      yield result.value;
    }
  } finally {
    if (options.preventCancel !== true) {
      await reader.cancel();
    }
    reader.releaseLock();
  }
}

// src/request/incrementalJSONParser.ts
var IncrementalJSONParser = class {
  buffer;
  bufferIndex;
  state;
  level;
  escaped;
  locked;
  constructor() {
    this.buffer = "";
    this.bufferIndex = 0;
    this.state = 0 /* EMPTY */;
    this.level = 0;
    this.escaped = false;
    this.locked = false;
  }
  write(chunk) {
    if (this.locked) {
      throw new Error("parser locked, make sure to drain the previous write");
    }
    this.locked = true;
    return this.writeGenerator(chunk);
  }
  /**
   * Is the written string fully consumed or we have buffered
   * data that needs to be processed
   */
  hasPending() {
    return this.buffer.length > 0;
  }
  /**
   * Did we call write() and the iterator is not exhausted yet
   */
  isLocked() {
    return this.locked;
  }
  *writeGenerator(chunk) {
    const workData = this.buffer + chunk;
    let lastLevel0 = 0;
    while (this.bufferIndex < workData.length) {
      if (this.state === 2 /* IN_DOUBLE_QUOTE_STRING */) {
        for (; this.bufferIndex < workData.length; this.bufferIndex++) {
          const c = workData[this.bufferIndex];
          if (this.escaped) {
            this.escaped = false;
          } else if (c === "\\") {
            this.escaped = true;
          } else if (c === '"') {
            this.state = 1 /* NORMAL */;
            this.bufferIndex++;
            break;
          }
        }
      } else {
        for (; this.bufferIndex < workData.length; this.bufferIndex++) {
          const c = workData[this.bufferIndex];
          if (c === "{") {
            this.level++;
          } else if (c === "}") {
            this.level--;
            if (this.level === 0) {
              const parsed = JSON.parse(
                workData.substring(lastLevel0, this.bufferIndex + 1)
              );
              yield parsed;
              lastLevel0 = this.bufferIndex + 1;
            }
          } else if (c === '"') {
            this.state = 2 /* IN_DOUBLE_QUOTE_STRING */;
            this.bufferIndex++;
            break;
          }
        }
      }
    }
    if (lastLevel0 > 0) {
      this.buffer = workData.substring(lastLevel0);
      this.bufferIndex -= lastLevel0;
    } else {
      this.buffer = workData;
    }
    this.locked = false;
  }
};

// src/request/handleStreamingResponseBody.ts
function handleStreamingResponseBody(responseBody, processJSON3) {
  return pipe(
    browserReadableStreamToIt(responseBody),
    async function* (source) {
      const decoder = new TextDecoder("utf-8");
      for await (const v of source) {
        yield decoder.decode(v, { stream: true });
      }
      return;
    },
    async function* (source) {
      const parser = new IncrementalJSONParser();
      for await (const v of source) {
        const parserSource = parser.write(v);
        for (const json of parserSource) {
          yield processJSON3(json);
        }
      }
      if (parser.hasPending()) {
        throw new Error("stream ended with unfinished data");
      }
    }
  );
}

// src/request/index.ts
var baseUrl = process.env.MODEL_FARM_URL ?? "https://production-modelfarm.replit.com/";
async function doFetch(urlPath, body) {
  const url = new URL(urlPath, baseUrl);
  const response = await fetch(url, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      Authorization: `Bearer ${await getToken()}`
    },
    body: JSON.stringify(body)
  });
  if (response.status !== 200) {
    return Err({
      message: await response.text(),
      statusCode: response.status
    });
  }
  if (!response.body) {
    return Err({
      message: "No response body",
      statusCode: response.status
    });
  }
  return Ok(
    response
  );
}
async function makeStreamingRequest(urlPath, body, processJSON3) {
  const res = await doFetch(urlPath, body);
  if (!res.ok) {
    return res;
  }
  const iterator = handleStreamingResponseBody(res.value.body, processJSON3);
  return Ok(iterator);
}
async function makeSimpleRequest(urlPath, body, processJSON3) {
  const res = await doFetch(urlPath, body);
  if (!res.ok) {
    return res;
  }
  const json = await res.value.json();
  return Ok(processJSON3(json));
}

// src/chat.ts
async function chatMultipleChoices(options) {
  return makeSimpleRequest(
    "/v1beta/chat",
    getRequestOptions(options),
    processJSON
  );
}
async function chatStream(options) {
  return makeStreamingRequest(
    "/v1beta/chat_streaming",
    getRequestOptions(options),
    (json) => {
      const { choices } = processJSON(json);
      const choice = choices[0];
      if (!choice) {
        throw new Error("Expected at least one choice");
      }
      return choice;
    }
  );
}
async function chat(options) {
  const res = await makeSimpleRequest(
    "/v1beta/chat",
    getRequestOptions(options),
    processJSON
  );
  if (!res.ok) {
    return res;
  }
  if (res.value.choices.length > 1) {
    throw new Error("Got multiple choices without choicesCount");
  }
  const choice = res.value.choices[0];
  if (!choice) {
    throw new Error("Expected at least one choice");
  }
  return Ok(choice);
}
function getRequestOptions(options) {
  return {
    model: options.model,
    parameters: {
      prompts: [
        {
          context: options.context ?? "",
          messages: options.messages
        }
      ],
      temperature: options.temperature,
      maxOutputTokens: options.maxOutputTokens,
      candidateCount: "choicesCount" in options ? options.choicesCount : void 0,
      ...options.extraParams
    }
  };
}
function processJSON(json) {
  if (!json.responses[0]?.candidates[0]?.message) {
    throw new Error("Expected at least one message");
  }
  return {
    choices: json.responses[0].candidates.map(({ message }) => ({
      message: {
        content: message.content,
        author: message.author
      }
    }))
  };
}

// src/complete.ts
async function completeMultipleChoices(options) {
  return makeSimpleRequest(
    "/v1beta/completion",
    getRequestOptions2(options),
    processJSON2
  );
}
async function complete(options) {
  const res = await makeSimpleRequest(
    "/v1beta/completion",
    getRequestOptions2(options),
    processJSON2
  );
  if (!res.ok) {
    return res;
  }
  if (res.value.choices.length > 1) {
    throw new Error("Got multiple choices without choicesCount");
  }
  const choice = res.value.choices[0];
  if (!choice) {
    throw new Error("Expected at least one choice");
  }
  return Ok(choice);
}
async function completeStream(options) {
  return makeStreamingRequest(
    "/v1beta/completion_streaming",
    getRequestOptions2(options),
    (json) => {
      const { choices } = processJSON2(json);
      const choice = choices[0];
      if (!choice) {
        throw new Error("Expected at least one choice");
      }
      return choice;
    }
  );
}
function getRequestOptions2(options) {
  return {
    model: options.model,
    parameters: {
      prompts: [options.prompt],
      temperature: options.temperature,
      maxOutputTokens: options.maxOutputTokens,
      candidateCount: "choicesCount" in options ? options.choicesCount : void 0,
      ...options.extraParams
    }
  };
}
function processJSON2(json) {
  if (!json.responses[0]?.choices[0]?.content) {
    throw new Error("Expected at least one message");
  }
  return {
    choices: json.responses[0].choices.map(({ content }) => ({
      completion: content
    }))
  };
}

// src/embed.ts
async function embed(options) {
  return makeSimpleRequest(
    "/v1beta/embedding",
    {
      model: options.model,
      parameters: {
        content: options.content.map((content) => ({ content })),
        ...options.extraParams
      }
    },
    (json) => ({
      embeddings: json.embeddings.map((embedding) => ({
        values: embedding.values,
        truncated: embedding.truncated
      }))
    })
  );
}
export {
  chat,
  chatMultipleChoices,
  chatStream,
  complete,
  completeMultipleChoices,
  completeStream,
  embed
};
//# sourceMappingURL=index.mjs.map