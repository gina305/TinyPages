/**
 * A Result type that can be used to represent a successful value or an error.
 * It forces the consumer to check whether the returned type is an error or not,
 * `result.ok` acts as a discriminant between success and failure
 * @public
 */
type Result<T, E = Error | string, ErrorExtras = unknown> = OkResult<T> | ErrResult<E, ErrorExtras>;
/**
 * Represents a successful result
 * @public
 */
interface OkResult<T> {
    ok: true;
    value: T;
    error?: undefined;
}
/**
 * Represents a failure result
 * @public
 */
interface ErrResult<E, ErrorExtras = unknown> {
    ok: false;
    error: E;
    value?: undefined;
    errorExtras?: ErrorExtras;
}

/**
 * An object that represents an error with a request
 * @public
 */
interface RequestError {
    message: string;
    statusCode: number;
}

/**
 * Available models for chat completion
 * @public
 */
type ChatModel = 'chat-bison';
/**
 * Options for chat request
 * @public
 */
interface ChatOptions {
    /**
     * Specifies the model to use
     */
    model: ChatModel;
    /**
     * This can be instructions for the model on how it should respond
     * or information it uses to generate a response. This can also be
     * used to restrict the model to a specific topic.
     */
    context?: string;
    /**
     * Previous messages in the conversation
     */
    messages: Array<ChatMessage>;
    /**
     * Sampling temperature between 0 and 1. The higher the value, the more
     * likely the model will produce a completion that is more creative and
     * imaginative.
     */
    temperature?: number;
    /**
     * The maximum number of tokens generated in the chat completion.
     * The absolute maximum value is limited by model's context size.
     */
    maxOutputTokens?: number;
    /**
     * Allows extra model specific parameters. Consult with the documentation for which
     * parameters are available for each model.
     */
    extraParams?: Record<string, unknown>;
}
/**
 * A message in a chat conversation
 * @public
 */
interface ChatMessage {
    /**
     * The content of the message
     */
    content: string;
    /**
     * The author of the message.
     * Typically the completion infers the author from examples and previous
     * messages provided in the options.
     */
    author: string;
}
interface ChatMultipleChoicesOptions extends ChatOptions {
    /**
     * Number of chat completions to generate. Minimum 1, the maximum
     * depends on the model, the returned choices will be automatically
     * adjusted to fit the model. You should not treat this as a guarantee,
     * what you will get is a number of choices up to `choicesCount`.
     */
    choicesCount: number;
}
/**
 * Gets multiple chat completions for a conversation.
 * @public
 */
declare function chatMultipleChoices(options: ChatMultipleChoicesOptions): Promise<Result<{
    choices: Array<{
        message: ChatMessage;
    }>;
}, RequestError>>;
/**
 * Gets a single chat message completion for a conversation.
 * The result contains an iterator of messages, please note that this would be
 * a *single message* that has the contents chunked up.
 * @public
 */
declare function chatStream(options: ChatOptions): Promise<Result<AsyncGenerator<{
    message: ChatMessage;
}>, RequestError>>;
/**
 * Gets a single chat message completion for a conversation.
 * @public
 */
declare function chat(options: ChatOptions): Promise<Result<{
    message: ChatMessage;
}, RequestError>>;

/**
 * Available models for text completion
 * @public
 */
type CompletionModel = 'text-bison';
/**
 * Options for completion request
 * @public
 */
interface CompletionOptions {
    /**
     * Specifies the model to use
     */
    model: CompletionModel;
    /**
     * The string/text to complete
     */
    prompt: string;
    /**
     * Sampling temperature between 0 and 1. The higher the value, the more
     * likely the model will produce a completion that is more creative and
     * imaginative.
     */
    temperature?: number;
    /**
     * The maximum number of tokens generated in the completion.
     * The absolute maximum value is limited by model's context size.
     */
    maxOutputTokens?: number;
    /**
     * Allows extra model specific parameters. Consult with the documentation for which
     * parameters are available for each model.
     */
    extraParams?: Record<string, unknown>;
}
interface CompletionMultipleChoicesOptions extends CompletionOptions {
    /**
     * Number of completions to generate. Minimum 1, the maximum
     * depends on the model, the returned choices will be automatically
     * adjusted to fit the model. You should not treat this as a guarantee,
     * what you will get is a number of choices upto `choicesCount`.
     */
    choicesCount: number;
}
/**
 * Gets multiple completions for a piece of text.
 * @public
 */
declare function completeMultipleChoices(options: CompletionMultipleChoicesOptions): Promise<Result<{
    choices: Array<{
        completion: string;
    }>;
}, RequestError>>;
/**
 * Gets the completion for a piece of text.
 * @public
 */
declare function complete(options: CompletionOptions): Promise<Result<{
    completion: string;
}, RequestError>>;
/**
 * Gets a stream of completions for a piece of text.
 * @public
 */
declare function completeStream(options: CompletionOptions): Promise<Result<AsyncGenerator<{
    completion: string;
}>, RequestError>>;

/**
 * Available models for text embedding
 * @public
 */
type EmbeddingModel = 'textembedding-gecko';
/**
 * Options for embedding request
 */
interface EmbeddingOptions {
    /**
     * The model to embed with
     */
    model: EmbeddingModel;
    /**
     * The strings to embed, the returned embedding will correspond to the order
     * of the passed string
     */
    content: Array<string>;
    /**
     * Allows extra model specific parameters. Consult with the documentation
     */
    extraParams?: Record<string, unknown>;
}
/**
 * Embedding vector returned by an embedding request
 * @public
 */
interface Embedding {
    /**
     * The embedding vectors corresponding to the words in the input text
     */
    values: Array<number>;
    /**
     * Indicates if the input text was longer than max allowed tokens and truncated
     */
    truncated: boolean;
}
/**
 * Converts text into numerical vectors
 * @public
 */
declare function embed(options: EmbeddingOptions): Promise<Result<{
    embeddings: Array<Embedding>;
}, RequestError>>;

export { ChatMessage, ChatModel, ChatMultipleChoicesOptions, ChatOptions, CompletionModel, CompletionMultipleChoicesOptions, CompletionOptions, Embedding, EmbeddingModel, EmbeddingOptions, ErrResult, OkResult, RequestError, Result, chat, chatMultipleChoices, chatStream, complete, completeMultipleChoices, completeStream, embed };
