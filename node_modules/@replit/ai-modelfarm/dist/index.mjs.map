{"version":3,"sources":["../src/result.ts","../src/request/getToken.ts","../node_modules/p-defer/index.js","../node_modules/it-pushable/src/fifo.ts","../node_modules/it-pushable/src/index.ts","../node_modules/it-merge/src/index.ts","../node_modules/it-pipe/src/index.ts","../node_modules/browser-readablestream-to-it/src/index.ts","../src/request/incrementalJSONParser.ts","../src/request/handleStreamingResponseBody.ts","../src/request/index.ts","../src/chat.ts","../src/complete.ts","../src/embed.ts"],"sourcesContent":["/**\n * A Result type that can be used to represent a successful value or an error.\n * It forces the consumer to check whether the returned type is an error or not,\n * `result.ok` acts as a discriminant between success and failure\n * @public\n */\nexport type Result<T, E = Error | string, ErrorExtras = unknown> =\n  | OkResult<T>\n  | ErrResult<E, ErrorExtras>;\n\n/**\n * Represents a successful result\n * @public\n */\nexport interface OkResult<T> {\n  ok: true;\n  value: T;\n  error?: undefined;\n}\n\n/**\n * Represents a failure result\n * @public\n */\nexport interface ErrResult<E, ErrorExtras = unknown> {\n  ok: false;\n  error: E;\n  value?: undefined;\n  errorExtras?: ErrorExtras;\n}\n\n/**\n * A helper function to create an error Result type\n */\nexport function Err<E, ErrorExtras>(\n  error: E,\n  errorExtras?: ErrorExtras,\n): ErrResult<E, ErrorExtras> {\n  return { ok: false, error, errorExtras };\n}\n\n/**\n * A helper function to create a successful Result type\n **/\nexport function Ok<T>(value: T): OkResult<T> {\n  return { ok: true, value };\n}\n","import { exec } from 'child_process';\n\nconst isDeployment = Boolean(process.env.REPLIT_DEPLOYMENT);\n\nasync function genReplIdentityToken(): Promise<string> {\n  return new Promise<string>((resolve, reject) => {\n    exec(\n      '$REPLIT_CLI identity create -audience=\"modelfarm@replit.com\"',\n      (error, stdout, stderr) => {\n        if (error) {\n          reject(`Getting identity token: ${error.name} ${error.message}`);\n          return;\n        }\n\n        if (stderr) {\n          reject(`Saw stderr getting identity token: ${stderr}`);\n          return;\n        }\n\n        resolve(stdout.trim());\n      },\n    );\n  });\n}\n\nasync function getDeploymentToken(): Promise<string> {\n  const res = await fetch('http://localhost:1105/getIdentityToken', {\n    body: JSON.stringify({ audience: 'modelfarm@replit.com' }),\n    headers: {\n      'Content-Type': 'application/json',\n    },\n    method: 'POST',\n  });\n\n  const json = (await res.json()) as unknown;\n\n  if (!json) {\n    throw new Error('Expected json to have identity token');\n  }\n\n  if (typeof json !== 'object') {\n    throw new Error('Expected json to be an object');\n  }\n\n  if (!('identityToken' in json)) {\n    throw new Error('Expected json to have identity token');\n  }\n\n  if (typeof json.identityToken !== 'string') {\n    throw new Error('Expected identity token to be a string');\n  }\n\n  return json.identityToken;\n}\n\nlet cachedToken: string | null = null;\n\nfunction resetTokenSoon() {\n  setTimeout(() => {\n    cachedToken = null;\n  }, 1000 * 30);\n}\n\nexport default async function getToken() {\n  if (!cachedToken) {\n    const fn = isDeployment ? getDeploymentToken : genReplIdentityToken;\n    cachedToken = await fn();\n    resetTokenSoon();\n  }\n\n  return cachedToken;\n}\n","export default function pDefer() {\n\tconst deferred = {};\n\n\tdeferred.promise = new Promise((resolve, reject) => {\n\t\tdeferred.resolve = resolve;\n\t\tdeferred.reject = reject;\n\t});\n\n\treturn deferred;\n}\n","// ported from https://www.npmjs.com/package/fast-fifo\n\nexport interface Next<T> {\n  done?: boolean\n  error?: Error\n  value?: T\n}\n\nclass FixedFIFO<T> {\n  public buffer: Array<Next<T> | undefined>\n  private readonly mask: number\n  private top: number\n  private btm: number\n  public next: FixedFIFO<T> | null\n\n  constructor (hwm: number) {\n    if (!(hwm > 0) || ((hwm - 1) & hwm) !== 0) {\n      throw new Error('Max size for a FixedFIFO should be a power of two')\n    }\n\n    this.buffer = new Array(hwm)\n    this.mask = hwm - 1\n    this.top = 0\n    this.btm = 0\n    this.next = null\n  }\n\n  push (data: Next<T>): boolean {\n    if (this.buffer[this.top] !== undefined) {\n      return false\n    }\n\n    this.buffer[this.top] = data\n    this.top = (this.top + 1) & this.mask\n\n    return true\n  }\n\n  shift (): Next<T> | undefined {\n    const last = this.buffer[this.btm]\n\n    if (last === undefined) {\n      return undefined\n    }\n\n    this.buffer[this.btm] = undefined\n    this.btm = (this.btm + 1) & this.mask\n    return last\n  }\n\n  isEmpty (): boolean {\n    return this.buffer[this.btm] === undefined\n  }\n}\n\nexport interface FIFOOptions {\n  /**\n   * When the queue reaches this size, it will be split into head/tail parts\n   */\n  splitLimit?: number\n}\n\nexport class FIFO<T> {\n  public size: number\n  private readonly hwm: number\n  private head: FixedFIFO<T>\n  private tail: FixedFIFO<T>\n\n  constructor (options: FIFOOptions = {}) {\n    this.hwm = options.splitLimit ?? 16\n    this.head = new FixedFIFO<T>(this.hwm)\n    this.tail = this.head\n    this.size = 0\n  }\n\n  calculateSize (obj: any): number {\n    if (obj?.byteLength != null) {\n      return obj.byteLength\n    }\n\n    return 1\n  }\n\n  push (val: Next<T>): void {\n    if (val?.value != null) {\n      this.size += this.calculateSize(val.value)\n    }\n\n    if (!this.head.push(val)) {\n      const prev = this.head\n      this.head = prev.next = new FixedFIFO<T>(2 * this.head.buffer.length)\n      this.head.push(val)\n    }\n  }\n\n  shift (): Next<T> | undefined {\n    let val = this.tail.shift()\n\n    if (val === undefined && (this.tail.next != null)) {\n      const next = this.tail.next\n      this.tail.next = null\n      this.tail = next\n      val = this.tail.shift()\n    }\n\n    if (val?.value != null) {\n      this.size -= this.calculateSize(val.value)\n    }\n\n    return val\n  }\n\n  isEmpty (): boolean {\n    return this.head.isEmpty()\n  }\n}\n","/**\n * @packageDocumentation\n *\n * An iterable that you can push values into.\n *\n * @example\n *\n * ```js\n * import { pushable } from 'it-pushable'\n *\n * const source = pushable()\n *\n * setTimeout(() => source.push('hello'), 100)\n * setTimeout(() => source.push('world'), 200)\n * setTimeout(() => source.end(), 300)\n *\n * const start = Date.now()\n *\n * for await (const value of source) {\n *   console.log(`got \"${value}\" after ${Date.now() - start}ms`)\n * }\n * console.log(`done after ${Date.now() - start}ms`)\n *\n * // Output:\n * // got \"hello\" after 105ms\n * // got \"world\" after 207ms\n * // done after 309ms\n * ```\n *\n * @example\n *\n * ```js\n * import { pushableV } from 'it-pushable'\n * import all from 'it-all'\n *\n * const source = pushableV()\n *\n * source.push(1)\n * source.push(2)\n * source.push(3)\n * source.end()\n *\n * console.info(await all(source))\n *\n * // Output:\n * // [ [1, 2, 3] ]\n * ```\n */\n\nimport deferred from 'p-defer'\nimport { FIFO, type Next } from './fifo.js'\n\nexport class AbortError extends Error {\n  type: string\n  code: string\n\n  constructor (message?: string, code?: string) {\n    super(message ?? 'The operation was aborted')\n    this.type = 'aborted'\n    this.code = code ?? 'ABORT_ERR'\n  }\n}\n\nexport interface AbortOptions {\n  signal?: AbortSignal\n}\n\ninterface BasePushable<T> {\n  /**\n   * End the iterable after all values in the buffer (if any) have been yielded. If an\n   * error is passed the buffer is cleared immediately and the next iteration will\n   * throw the passed error\n   */\n  end: (err?: Error) => this\n\n  /**\n   * Push a value into the iterable. Values are yielded from the iterable in the order\n   * they are pushed. Values not yet consumed from the iterable are buffered.\n   */\n  push: (value: T) => this\n\n  /**\n   * Returns a promise that resolves when the underlying queue becomes empty (e.g.\n   * this.readableLength === 0).\n   *\n   * If an AbortSignal is passed as an option and that signal aborts, it only\n   * causes the returned promise to reject - it does not end the pushable.\n   */\n  onEmpty: (options?: AbortOptions) => Promise<void>\n\n  /**\n   * This property contains the number of bytes (or objects) in the queue ready to be read.\n   *\n   * If `objectMode` is true, this is the number of objects in the queue, if false it's the\n   * total number of bytes in the queue.\n   */\n  readableLength: number\n}\n\n/**\n * An iterable that you can push values into.\n */\nexport interface Pushable<T, R = void, N = unknown> extends AsyncGenerator<T, R, N>, BasePushable<T> {}\n\n/**\n * Similar to `pushable`, except it yields multiple buffered chunks at a time. All values yielded from the iterable will be arrays.\n */\nexport interface PushableV<T, R = void, N = unknown> extends AsyncGenerator<T[], R, N>, BasePushable<T> {}\n\nexport interface Options {\n  /**\n   * A boolean value that means non-`Uint8Array`s will be passed to `.push`, default: `false`\n   */\n  objectMode?: boolean\n\n  /**\n   * A function called after *all* values have been yielded from the iterator (including\n   * buffered values). In the case when the iterator is ended with an error it will be\n   * passed the error as a parameter.\n   */\n  onEnd?: (err?: Error) => void\n}\n\nexport interface DoneResult { done: true }\nexport interface ValueResult<T> { done: false, value: T }\nexport type NextResult<T> = ValueResult<T> | DoneResult\n\ninterface getNext<T, V = T> { (buffer: FIFO<T>): NextResult<V> }\n\nexport interface ObjectPushableOptions extends Options {\n  objectMode: true\n}\n\nexport interface BytePushableOptions extends Options {\n  objectMode?: false\n}\n\n/**\n * Create a new async iterable. The values yielded from calls to `.next()`\n * or when used in a `for await of`loop are \"pushed\" into the iterable.\n * Returns an async iterable object with additional methods.\n */\nexport function pushable<T extends { byteLength: number } = Uint8Array> (options?: BytePushableOptions): Pushable<T>\nexport function pushable<T> (options: ObjectPushableOptions): Pushable<T>\nexport function pushable<T> (options: Options = {}): Pushable<T> {\n  const getNext = (buffer: FIFO<T>): NextResult<T> => {\n    const next: Next<T> | undefined = buffer.shift()\n\n    if (next == null) {\n      return { done: true }\n    }\n\n    if (next.error != null) {\n      throw next.error\n    }\n\n    return {\n      done: next.done === true,\n      // @ts-expect-error if done is false, value will be present\n      value: next.value\n    }\n  }\n\n  return _pushable<T, T, Pushable<T>>(getNext, options)\n}\n\nexport function pushableV<T extends { byteLength: number } = Uint8Array> (options?: BytePushableOptions): PushableV<T>\nexport function pushableV<T> (options: ObjectPushableOptions): PushableV<T>\nexport function pushableV<T> (options: Options = {}): PushableV<T> {\n  const getNext = (buffer: FIFO<T>): NextResult<T[]> => {\n    let next: Next<T> | undefined\n    const values: T[] = []\n\n    while (!buffer.isEmpty()) {\n      next = buffer.shift()\n\n      if (next == null) {\n        break\n      }\n\n      if (next.error != null) {\n        throw next.error\n      }\n\n      if (next.done === false) {\n        // @ts-expect-error if done is false value should be pushed\n        values.push(next.value)\n      }\n    }\n\n    if (next == null) {\n      return { done: true }\n    }\n\n    return {\n      done: next.done === true,\n      value: values\n    }\n  }\n\n  return _pushable<T, T[], PushableV<T>>(getNext, options)\n}\n\nfunction _pushable<PushType, ValueType, ReturnType> (getNext: getNext<PushType, ValueType>, options?: Options): ReturnType {\n  options = options ?? {}\n  let onEnd = options.onEnd\n  let buffer = new FIFO<PushType>()\n  let pushable: any\n  let onNext: ((next: Next<PushType>) => ReturnType) | null\n  let ended: boolean\n  let drain = deferred()\n\n  const waitNext = async (): Promise<NextResult<ValueType>> => {\n    try {\n      if (!buffer.isEmpty()) {\n        return getNext(buffer)\n      }\n\n      if (ended) {\n        return { done: true }\n      }\n\n      return await new Promise<NextResult<ValueType>>((resolve, reject) => {\n        onNext = (next: Next<PushType>) => {\n          onNext = null\n          buffer.push(next)\n\n          try {\n            resolve(getNext(buffer))\n          } catch (err) {\n            reject(err)\n          }\n\n          return pushable\n        }\n      })\n    } finally {\n      if (buffer.isEmpty()) {\n        // settle promise in the microtask queue to give consumers a chance to\n        // await after calling .push\n        queueMicrotask(() => {\n          drain.resolve()\n          drain = deferred()\n        })\n      }\n    }\n  }\n\n  const bufferNext = (next: Next<PushType>): ReturnType => {\n    if (onNext != null) {\n      return onNext(next)\n    }\n\n    buffer.push(next)\n    return pushable\n  }\n\n  const bufferError = (err: Error): ReturnType => {\n    buffer = new FIFO()\n\n    if (onNext != null) {\n      return onNext({ error: err })\n    }\n\n    buffer.push({ error: err })\n    return pushable\n  }\n\n  const push = (value: PushType): ReturnType => {\n    if (ended) {\n      return pushable\n    }\n\n    // @ts-expect-error `byteLength` is not declared on PushType\n    if (options?.objectMode !== true && value?.byteLength == null) {\n      throw new Error('objectMode was not true but tried to push non-Uint8Array value')\n    }\n\n    return bufferNext({ done: false, value })\n  }\n  const end = (err?: Error): ReturnType => {\n    if (ended) return pushable\n    ended = true\n\n    return (err != null) ? bufferError(err) : bufferNext({ done: true })\n  }\n  const _return = (): DoneResult => {\n    buffer = new FIFO()\n    end()\n\n    return { done: true }\n  }\n  const _throw = (err: Error): DoneResult => {\n    end(err)\n\n    return { done: true }\n  }\n\n  pushable = {\n    [Symbol.asyncIterator] () { return this },\n    next: waitNext,\n    return: _return,\n    throw: _throw,\n    push,\n    end,\n    get readableLength (): number {\n      return buffer.size\n    },\n    onEmpty: async (options?: AbortOptions) => {\n      const signal = options?.signal\n      signal?.throwIfAborted()\n\n      if (buffer.isEmpty()) {\n        return\n      }\n\n      let cancel: Promise<void> | undefined\n      let listener: (() => void) | undefined\n\n      if (signal != null) {\n        cancel = new Promise((resolve, reject) => {\n          listener = () => {\n            reject(new AbortError())\n          }\n\n          signal.addEventListener('abort', listener)\n        })\n      }\n\n      try {\n        await Promise.race([\n          drain.promise,\n          cancel\n        ])\n      } finally {\n        if (listener != null && signal != null) {\n          signal?.removeEventListener('abort', listener)\n        }\n      }\n    }\n  }\n\n  if (onEnd == null) {\n    return pushable\n  }\n\n  const _pushable = pushable\n\n  pushable = {\n    [Symbol.asyncIterator] () { return this },\n    next () {\n      return _pushable.next()\n    },\n    throw (err: Error) {\n      _pushable.throw(err)\n\n      if (onEnd != null) {\n        onEnd(err)\n        onEnd = undefined\n      }\n\n      return { done: true }\n    },\n    return () {\n      _pushable.return()\n\n      if (onEnd != null) {\n        onEnd()\n        onEnd = undefined\n      }\n\n      return { done: true }\n    },\n    push,\n    end (err: Error) {\n      _pushable.end(err)\n\n      if (onEnd != null) {\n        onEnd(err)\n        onEnd = undefined\n      }\n\n      return pushable\n    },\n    get readableLength () {\n      return _pushable.readableLength\n    }\n  }\n\n  return pushable\n}\n","import { pushable } from 'it-pushable'\n\nfunction isAsyncIterable <T> (thing: any): thing is AsyncIterable<T> {\n  return thing[Symbol.asyncIterator] != null\n}\n\n/**\n * Treat one or more iterables as a single iterable.\n *\n * Nb. sources are iterated over in parallel so the\n * order of emitted items is not guaranteed.\n */\nfunction merge <T> (...sources: Array<Iterable<T>>): Generator<T, void, undefined>\nfunction merge <T> (...sources: Array<AsyncIterable<T> | Iterable<T>>): AsyncGenerator<T, void, undefined>\nfunction merge <T> (...sources: Array<AsyncIterable<T> | Iterable<T>>): AsyncGenerator<T, void, undefined> | Generator<T, void, undefined> {\n  const syncSources: Array<Iterable<T>> = []\n\n  for (const source of sources) {\n    if (!isAsyncIterable(source)) {\n      syncSources.push(source)\n    }\n  }\n\n  if (syncSources.length === sources.length) {\n    // all sources are synchronous\n    return (function * () {\n      for (const source of syncSources) {\n        yield * source\n      }\n    })()\n  }\n\n  return (async function * () {\n    const output = pushable<T>({\n      objectMode: true\n    })\n\n    void Promise.resolve().then(async () => {\n      try {\n        await Promise.all(\n          sources.map(async (source) => {\n            for await (const item of source) {\n              output.push(item)\n            }\n          })\n        )\n\n        output.end()\n      } catch (err: any) {\n        output.end(err)\n      }\n    })\n\n    yield * output\n  })()\n}\n\nexport default merge\n","import { pushable } from 'it-pushable'\nimport merge from 'it-merge'\nimport type { Duplex, Transform, Sink } from 'it-stream-types'\n\ninterface SourceFn<A = any> { (): A }\n\ntype PipeSource<A = any> =\n  Iterable<A> |\n  AsyncIterable<A> |\n  SourceFn<A> |\n  Duplex<A, any, any>\n\ntype PipeTransform<A = any, B = any> =\n  Transform<A, B> |\n  Duplex<B, A>\n\ntype PipeSink<A = any, B = any> =\n  Sink<A, B> |\n  Duplex<any, A, B>\n\ntype PipeOutput<A> =\n  A extends Sink<any> ? ReturnType<A> :\n    A extends Duplex<any, any, any> ? ReturnType<A['sink']> :\n      never\n\n// single item pipe output includes pipe source types\ntype SingleItemPipeOutput<A> =\n  A extends Iterable<any> ? A :\n    A extends AsyncIterable<any> ? A :\n      A extends SourceFn ? ReturnType<A> :\n        A extends Duplex<any, any, any> ? A['source'] :\n          PipeOutput<A>\n\ntype PipeFnInput<A> =\n  A extends Iterable<any> ? A :\n    A extends AsyncIterable<any> ? A :\n      A extends SourceFn ? ReturnType<A> :\n        A extends Transform<any, any> ? ReturnType<A> :\n          A extends Duplex<any, any, any> ? A['source'] :\n            never\n\n// one item, just a pass-through\nexport function pipe<\n  A extends PipeSource\n> (\n  source: A\n): SingleItemPipeOutput<A>\n\n// two items, source to sink\nexport function pipe<\n  A extends PipeSource,\n  B extends PipeSink<PipeFnInput<A>>\n> (\n  source: A,\n  sink: B\n): PipeOutput<B>\n\n// three items, source to sink with transform(s) in between\nexport function pipe<\n  A extends PipeSource,\n  B extends PipeTransform<PipeFnInput<A>>,\n  C extends PipeSink<PipeFnInput<B>>\n> (\n  source: A,\n  transform1: B,\n  sink: C\n): PipeOutput<C>\n\n// many items, source to sink with transform(s) in between\nexport function pipe<\n  A extends PipeSource,\n  B extends PipeTransform<PipeFnInput<A>>,\n  C extends PipeTransform<PipeFnInput<B>>,\n  D extends PipeSink<PipeFnInput<C>>\n> (\n  source: A,\n  transform1: B,\n  transform2: C,\n  sink: D\n): PipeOutput<D>\n\n// lots of items, source to sink with transform(s) in between\nexport function pipe<\n  A extends PipeSource,\n  B extends PipeTransform<PipeFnInput<A>>,\n  C extends PipeTransform<PipeFnInput<B>>,\n  D extends PipeTransform<PipeFnInput<C>>,\n  E extends PipeSink<PipeFnInput<D>>\n> (\n  source: A,\n  transform1: B,\n  transform2: C,\n  transform3: D,\n  sink: E\n): PipeOutput<E>\n\n// lots of items, source to sink with transform(s) in between\nexport function pipe<\n  A extends PipeSource,\n  B extends PipeTransform<PipeFnInput<A>>,\n  C extends PipeTransform<PipeFnInput<B>>,\n  D extends PipeTransform<PipeFnInput<C>>,\n  E extends PipeTransform<PipeFnInput<D>>,\n  F extends PipeSink<PipeFnInput<E>>\n> (\n  source: A,\n  transform1: B,\n  transform2: C,\n  transform3: D,\n  transform4: E,\n  sink: F\n): PipeOutput<F>\n\n// lots of items, source to sink with transform(s) in between\nexport function pipe<\n  A extends PipeSource,\n  B extends PipeTransform<PipeFnInput<A>>,\n  C extends PipeTransform<PipeFnInput<B>>,\n  D extends PipeTransform<PipeFnInput<C>>,\n  E extends PipeTransform<PipeFnInput<D>>,\n  F extends PipeTransform<PipeFnInput<E>>,\n  G extends PipeSink<PipeFnInput<F>>\n> (\n  source: A,\n  transform1: B,\n  transform2: C,\n  transform3: D,\n  transform4: E,\n  transform5: F,\n  sink: G\n): PipeOutput<G>\n\n// lots of items, source to sink with transform(s) in between\nexport function pipe<\n  A extends PipeSource,\n  B extends PipeTransform<PipeFnInput<A>>,\n  C extends PipeTransform<PipeFnInput<B>>,\n  D extends PipeTransform<PipeFnInput<C>>,\n  E extends PipeTransform<PipeFnInput<D>>,\n  F extends PipeTransform<PipeFnInput<E>>,\n  G extends PipeTransform<PipeFnInput<F>>,\n  H extends PipeSink<PipeFnInput<G>>\n> (\n  source: A,\n  transform1: B,\n  transform2: C,\n  transform3: D,\n  transform4: E,\n  transform5: F,\n  transform6: G,\n  sink: H\n): PipeOutput<H>\n\n// lots of items, source to sink with transform(s) in between\nexport function pipe<\n  A extends PipeSource,\n  B extends PipeTransform<PipeFnInput<A>>,\n  C extends PipeTransform<PipeFnInput<B>>,\n  D extends PipeTransform<PipeFnInput<C>>,\n  E extends PipeTransform<PipeFnInput<D>>,\n  F extends PipeTransform<PipeFnInput<E>>,\n  G extends PipeTransform<PipeFnInput<F>>,\n  H extends PipeTransform<PipeFnInput<G>>,\n  I extends PipeSink<PipeFnInput<H>>\n> (\n  source: A,\n  transform1: B,\n  transform2: C,\n  transform3: D,\n  transform4: E,\n  transform5: F,\n  transform6: G,\n  transform7: H,\n  sink: I\n): PipeOutput<I>\n\n// lots of items, source to sink with transform(s) in between\nexport function pipe<\n  A extends PipeSource,\n  B extends PipeTransform<PipeFnInput<A>>,\n  C extends PipeTransform<PipeFnInput<B>>,\n  D extends PipeTransform<PipeFnInput<C>>,\n  E extends PipeTransform<PipeFnInput<D>>,\n  F extends PipeTransform<PipeFnInput<E>>,\n  G extends PipeTransform<PipeFnInput<F>>,\n  H extends PipeTransform<PipeFnInput<G>>,\n  I extends PipeTransform<PipeFnInput<H>>,\n  J extends PipeSink<PipeFnInput<I>>\n> (\n  source: A,\n  transform1: B,\n  transform2: C,\n  transform3: D,\n  transform4: E,\n  transform5: F,\n  transform6: G,\n  transform7: H,\n  transform8: I,\n  sink: J\n): PipeOutput<J>\n\n// lots of items, source to sink with transform(s) in between\nexport function pipe<\n  A extends PipeSource,\n  B extends PipeTransform<PipeFnInput<A>>,\n  C extends PipeTransform<PipeFnInput<B>>,\n  D extends PipeTransform<PipeFnInput<C>>,\n  E extends PipeTransform<PipeFnInput<D>>,\n  F extends PipeTransform<PipeFnInput<E>>,\n  G extends PipeTransform<PipeFnInput<F>>,\n  H extends PipeTransform<PipeFnInput<G>>,\n  I extends PipeTransform<PipeFnInput<H>>,\n  J extends PipeTransform<PipeFnInput<I>>,\n  K extends PipeSink<PipeFnInput<J>>\n> (\n  source: A,\n  transform1: B,\n  transform2: C,\n  transform3: D,\n  transform4: E,\n  transform5: F,\n  transform6: G,\n  transform7: H,\n  transform8: I,\n  transform9: J,\n  sink: K\n): PipeOutput<K>\n\n// lots of items, source to sink with transform(s) in between\nexport function pipe<\n  A extends PipeSource,\n  B extends PipeTransform<PipeFnInput<A>>,\n  C extends PipeTransform<PipeFnInput<B>>,\n  D extends PipeTransform<PipeFnInput<C>>,\n  E extends PipeTransform<PipeFnInput<D>>,\n  F extends PipeTransform<PipeFnInput<E>>,\n  G extends PipeTransform<PipeFnInput<F>>,\n  H extends PipeTransform<PipeFnInput<G>>,\n  I extends PipeTransform<PipeFnInput<H>>,\n  J extends PipeTransform<PipeFnInput<I>>,\n  K extends PipeTransform<PipeFnInput<J>>,\n  L extends PipeSink<PipeFnInput<K>>\n> (\n  source: A,\n  transform1: B,\n  transform2: C,\n  transform3: D,\n  transform4: E,\n  transform5: F,\n  transform6: G,\n  transform7: H,\n  transform8: I,\n  transform9: J,\n  transform10: K,\n  sink: L\n): PipeOutput<L>\n\nexport function pipe (first: any, ...rest: any[]): any {\n  if (first == null) {\n    throw new Error('Empty pipeline')\n  }\n\n  // Duplex at start: wrap in function and return duplex source\n  if (isDuplex(first)) {\n    const duplex = first\n    first = () => duplex.source\n  // Iterable at start: wrap in function\n  } else if (isIterable(first) || isAsyncIterable(first)) {\n    const source = first\n    first = () => source\n  }\n\n  const fns = [first, ...rest]\n\n  if (fns.length > 1) {\n    // Duplex at end: use duplex sink\n    if (isDuplex(fns[fns.length - 1])) {\n      fns[fns.length - 1] = fns[fns.length - 1].sink\n    }\n  }\n\n  if (fns.length > 2) {\n    // Duplex in the middle, consume source with duplex sink and return duplex source\n    for (let i = 1; i < fns.length - 1; i++) {\n      if (isDuplex(fns[i])) {\n        fns[i] = duplexPipelineFn(fns[i])\n      }\n    }\n  }\n\n  return rawPipe(...fns)\n}\n\nexport const rawPipe = (...fns: any): any => {\n  let res\n  while (fns.length > 0) {\n    res = fns.shift()(res)\n  }\n  return res\n}\n\nconst isAsyncIterable = (obj: any): obj is AsyncIterable<unknown> => {\n  return obj?.[Symbol.asyncIterator] != null\n}\n\nconst isIterable = (obj: any): obj is Iterable<unknown> => {\n  return obj?.[Symbol.iterator] != null\n}\n\nconst isDuplex = (obj: any): obj is Duplex => {\n  if (obj == null) {\n    return false\n  }\n\n  return obj.sink != null && obj.source != null\n}\n\nconst duplexPipelineFn = (duplex: Duplex<any, any, any>) => {\n  return (source: any) => {\n    const p = duplex.sink(source)\n\n    if (p?.then != null) {\n      const stream = pushable<any>({\n        objectMode: true\n      })\n      p.then(() => {\n        stream.end()\n      }, (err: Error) => {\n        stream.end(err)\n      })\n\n      let sourceWrap: () => Iterable<any> | AsyncIterable<any>\n      const source = duplex.source\n\n      if (isAsyncIterable(source)) {\n        sourceWrap = async function * () {\n          yield * source\n          stream.end()\n        }\n      } else if (isIterable(source)) {\n        sourceWrap = function * () {\n          yield * source\n          stream.end()\n        }\n      } else {\n        throw new Error('Unknown duplex source type - must be Iterable or AsyncIterable')\n      }\n\n      return merge(stream, sourceWrap())\n    }\n\n    return duplex.source\n  }\n}\n","export interface BrowserReadableStreamToItOptions {\n  preventCancel?: boolean\n}\n\n/**\n * Turns a browser readable stream into an async iterable. Async iteration over\n * returned iterable will lock give stream, preventing any other consumer from\n * acquiring a reader. The lock will be released if iteration loop is broken. To\n * prevent stream cancelling optional `{ preventCancel: true }` could be passed\n * as a second argument.\n */\nexport default async function * browserReadableStreamToIt <T> (stream: ReadableStream<T>, options: BrowserReadableStreamToItOptions = {}): AsyncGenerator<T, void, undefined> {\n  const reader = stream.getReader()\n\n  try {\n    while (true) {\n      const result = await reader.read()\n\n      if (result.done) {\n        return\n      }\n\n      yield result.value\n    }\n  } finally {\n    if (options.preventCancel !== true) {\n      await reader.cancel()\n    }\n\n    reader.releaseLock()\n  }\n}\n","enum State {\n  EMPTY = 0,\n  IN_DOUBLE_QUOTE_STRING = 2,\n  NORMAL = 1,\n}\n\n/**\n * This parses a stream of JSON that may be incomplete\n * after every chunk\n */\nexport default class IncrementalJSONParser<T> {\n  private buffer: string;\n  private bufferIndex: number;\n  private state: State;\n  private level: number;\n  private escaped: boolean;\n  private locked: boolean;\n\n  constructor() {\n    this.buffer = '';\n    this.bufferIndex = 0;\n    // State at the last read character.\n    this.state = State.EMPTY;\n    this.level = 0;\n    this.escaped = false;\n    this.locked = false;\n  }\n\n  public write(chunk: string) {\n    if (this.locked) {\n      throw new Error('parser locked, make sure to drain the previous write');\n    }\n\n    this.locked = true;\n\n    return this.writeGenerator(chunk);\n  }\n\n  /**\n   * Is the written string fully consumed or we have buffered\n   * data that needs to be processed\n   */\n  public hasPending() {\n    return this.buffer.length > 0;\n  }\n\n  /**\n   * Did we call write() and the iterator is not exhausted yet\n   */\n  public isLocked() {\n    return this.locked;\n  }\n\n  private *writeGenerator(chunk: string): Generator<T, void, void> {\n    // Push the data into the system, and then process any pending content\n    const workData = this.buffer + chunk;\n    let lastLevel0 = 0;\n    while (this.bufferIndex < workData.length) {\n      if (this.state === State.IN_DOUBLE_QUOTE_STRING) {\n        // Look for the next unescaped quote\n        for (; this.bufferIndex < workData.length; this.bufferIndex++) {\n          const c = workData[this.bufferIndex];\n          if (this.escaped) {\n            this.escaped = false;\n          } else if (c === '\\\\') {\n            this.escaped = true;\n          } else if (c === '\"') {\n            this.state = State.NORMAL;\n            this.bufferIndex++;\n            break;\n          }\n        }\n      } else {\n        // Process content regularly until we find a string start\n        for (; this.bufferIndex < workData.length; this.bufferIndex++) {\n          const c = workData[this.bufferIndex];\n          if (c === '{') {\n            this.level++;\n          } else if (c === '}') {\n            this.level--;\n            if (this.level === 0) {\n              // Parse the block until now\n              const parsed = JSON.parse(\n                workData.substring(lastLevel0, this.bufferIndex + 1),\n              ) as T;\n              yield parsed;\n\n              // Reset buffer to the section from now\n              lastLevel0 = this.bufferIndex + 1;\n            }\n          } else if (c === '\"') {\n            this.state = State.IN_DOUBLE_QUOTE_STRING;\n            this.bufferIndex++;\n            break;\n          }\n        }\n      }\n    }\n\n    if (lastLevel0 > 0) {\n      this.buffer = workData.substring(lastLevel0);\n      this.bufferIndex -= lastLevel0;\n    } else {\n      this.buffer = workData;\n    }\n\n    this.locked = false;\n  }\n}\n","import { pipe } from 'it-pipe';\nimport streamToIterator from 'browser-readablestream-to-it';\nimport IncrementalJSONParser from './incrementalJSONParser';\n\nexport default function handleStreamingResponseBody<T, R>(\n  responseBody: ReadableStream<Uint8Array>,\n  processJSON: (json: T) => R,\n): AsyncGenerator<R> {\n  return pipe(\n    streamToIterator(responseBody),\n    async function* (source) {\n      const decoder = new TextDecoder('utf-8');\n\n      for await (const v of source) {\n        yield decoder.decode(v, { stream: true });\n      }\n\n      return;\n    },\n    async function* (source): AsyncGenerator<R> {\n      const parser = new IncrementalJSONParser();\n      for await (const v of source) {\n        const parserSource = parser.write(v);\n\n        for (const json of parserSource) {\n          // Ideally we do some assertions on T here\n          yield processJSON(json as T);\n        }\n      }\n\n      if (parser.hasPending()) {\n        throw new Error('stream ended with unfinished data');\n      }\n    },\n  );\n}\n","import * as result from '../result';\nimport getToken from './getToken';\nimport handleStreamingResponseBody from './handleStreamingResponseBody';\n\n/**\n * An object that represents an error with a request\n * @public\n */\nexport interface RequestError {\n  message: string;\n  statusCode: number;\n}\n\nexport const baseUrl =\n  process.env.MODEL_FARM_URL ?? 'https://production-modelfarm.replit.com/';\n\nexport async function doFetch(\n  urlPath: string,\n  body: Record<string, unknown>,\n): Promise<\n  result.Result<\n    Response & { body: NonNullable<Response['body']> },\n    RequestError\n  >\n> {\n  const url = new URL(urlPath, baseUrl);\n\n  const response = await fetch(url, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n      Authorization: `Bearer ${await getToken()}`,\n    },\n    body: JSON.stringify(body),\n  });\n\n  if (response.status !== 200) {\n    return result.Err({\n      message: await response.text(),\n      statusCode: response.status,\n    });\n  }\n\n  if (!response.body) {\n    return result.Err({\n      message: 'No response body',\n      statusCode: response.status,\n    });\n  }\n\n  return result.Ok(\n    response as Response & { body: NonNullable<Response['body']> },\n  );\n}\n\nexport async function makeStreamingRequest<T, R>(\n  urlPath: string,\n  body: Record<string, unknown>,\n  processJSON: (json: T) => R,\n): Promise<result.Result<AsyncGenerator<R, void, void>, RequestError>> {\n  const res = await doFetch(urlPath, body);\n\n  if (!res.ok) {\n    return res;\n  }\n\n  const iterator = handleStreamingResponseBody(res.value.body, processJSON);\n\n  return result.Ok(iterator);\n}\n\nexport async function makeSimpleRequest<T, R>(\n  urlPath: string,\n  body: Record<string, unknown>,\n  processJSON: (json: T) => R,\n): Promise<result.Result<R, RequestError>> {\n  const res = await doFetch(urlPath, body);\n\n  if (!res.ok) {\n    return res;\n  }\n\n  const json = (await res.value.json()) as T;\n\n  return result.Ok(processJSON(json));\n}\n","import * as result from './result';\nimport {\n  makeStreamingRequest,\n  makeSimpleRequest,\n  RequestError,\n} from './request';\n\n/**\n * Available models for chat completion\n * @public\n */\nexport type ChatModel = 'chat-bison';\n\n/**\n * Options for chat request\n * @public\n */\nexport interface ChatOptions {\n  /**\n   * Specifies the model to use\n   */\n  model: ChatModel;\n  /**\n   * This can be instructions for the model on how it should respond\n   * or information it uses to generate a response. This can also be\n   * used to restrict the model to a specific topic.\n   */\n  context?: string;\n  /**\n   * Previous messages in the conversation\n   */\n  messages: Array<ChatMessage>;\n  /**\n   * Sampling temperature between 0 and 1. The higher the value, the more\n   * likely the model will produce a completion that is more creative and\n   * imaginative.\n   */\n  temperature?: number;\n  /**\n   * The maximum number of tokens generated in the chat completion.\n   * The absolute maximum value is limited by model's context size.\n   */\n  maxOutputTokens?: number;\n\n  /**\n   * Allows extra model specific parameters. Consult with the documentation for which\n   * parameters are available for each model.\n   */\n  extraParams?: Record<string, unknown>;\n}\n\n/**\n * A message in a chat conversation\n * @public\n */\nexport interface ChatMessage {\n  /**\n   * The content of the message\n   */\n  content: string;\n  /**\n   * The author of the message.\n   * Typically the completion infers the author from examples and previous\n   * messages provided in the options.\n   */\n  author: string;\n}\n\nexport interface ChatMultipleChoicesOptions extends ChatOptions {\n  /**\n   * Number of chat completions to generate. Minimum 1, the maximum\n   * depends on the model, the returned choices will be automatically\n   * adjusted to fit the model. You should not treat this as a guarantee,\n   * what you will get is a number of choices up to `choicesCount`.\n   */\n  choicesCount: number;\n}\n\n/**\n * Gets multiple chat completions for a conversation.\n * @public\n */\nexport async function chatMultipleChoices(\n  options: ChatMultipleChoicesOptions,\n): Promise<\n  result.Result<{ choices: Array<{ message: ChatMessage }> }, RequestError>\n> {\n  return makeSimpleRequest(\n    '/v1beta/chat',\n    getRequestOptions(options),\n    processJSON,\n  );\n}\n\n// non exauhstive\ninterface RawAPIResponse {\n  responses: Array<{\n    candidates: Array<{\n      message: ChatMessage;\n    }>;\n  }>;\n}\n\n/**\n * Gets a single chat message completion for a conversation.\n * The result contains an iterator of messages, please note that this would be\n * a *single message* that has the contents chunked up.\n * @public\n */\nexport async function chatStream(\n  options: ChatOptions,\n): Promise<\n  result.Result<AsyncGenerator<{ message: ChatMessage }>, RequestError>\n> {\n  return makeStreamingRequest(\n    '/v1beta/chat_streaming',\n    getRequestOptions(options),\n    (json: RawAPIResponse) => {\n      const { choices } = processJSON(json);\n\n      const choice = choices[0];\n\n      if (!choice) {\n        throw new Error('Expected at least one choice');\n      }\n\n      return choice;\n    },\n  );\n}\n\n/**\n * Gets a single chat message completion for a conversation.\n * @public\n */\nexport async function chat(\n  options: ChatOptions,\n): Promise<result.Result<{ message: ChatMessage }, RequestError>> {\n  const res = await makeSimpleRequest(\n    '/v1beta/chat',\n    getRequestOptions(options),\n    processJSON,\n  );\n\n  if (!res.ok) {\n    return res;\n  }\n\n  if (res.value.choices.length > 1) {\n    throw new Error('Got multiple choices without choicesCount');\n  }\n\n  const choice = res.value.choices[0];\n\n  if (!choice) {\n    throw new Error('Expected at least one choice');\n  }\n\n  return result.Ok(choice);\n}\n\nfunction getRequestOptions(\n  options: ChatOptions | ChatMultipleChoicesOptions,\n): Record<string, unknown> {\n  return {\n    model: options.model,\n    parameters: {\n      prompts: [\n        {\n          context: options.context ?? '',\n          messages: options.messages,\n        },\n      ],\n      temperature: options.temperature,\n      maxOutputTokens: options.maxOutputTokens,\n      candidateCount:\n        'choicesCount' in options ? options.choicesCount : undefined,\n      ...options.extraParams,\n    },\n  };\n}\n\nfunction processJSON(json: RawAPIResponse): {\n  choices: Array<{ message: ChatMessage }>;\n} {\n  if (!json.responses[0]?.candidates[0]?.message) {\n    throw new Error('Expected at least one message');\n  }\n\n  return {\n    choices: json.responses[0].candidates.map(({ message }) => ({\n      message: {\n        content: message.content,\n        author: message.author,\n      },\n    })),\n  };\n}\n","import * as result from './result';\nimport {\n  RequestError,\n  makeSimpleRequest,\n  makeStreamingRequest,\n} from './request';\n\n/**\n * Available models for text completion\n * @public\n */\nexport type CompletionModel = 'text-bison';\n\n/**\n * Options for completion request\n * @public\n */\nexport interface CompletionOptions {\n  /**\n   * Specifies the model to use\n   */\n  model: CompletionModel;\n  /**\n   * The string/text to complete\n   */\n  prompt: string;\n  /**\n   * Sampling temperature between 0 and 1. The higher the value, the more\n   * likely the model will produce a completion that is more creative and\n   * imaginative.\n   */\n  temperature?: number;\n  /**\n   * The maximum number of tokens generated in the completion.\n   * The absolute maximum value is limited by model's context size.\n   */\n  maxOutputTokens?: number;\n\n  /**\n   * Allows extra model specific parameters. Consult with the documentation for which\n   * parameters are available for each model.\n   */\n  extraParams?: Record<string, unknown>;\n}\n\nexport interface CompletionMultipleChoicesOptions extends CompletionOptions {\n  /**\n   * Number of completions to generate. Minimum 1, the maximum\n   * depends on the model, the returned choices will be automatically\n   * adjusted to fit the model. You should not treat this as a guarantee,\n   * what you will get is a number of choices upto `choicesCount`.\n   */\n  choicesCount: number;\n}\n\n// non exauhstive\ninterface RawAPIResponse {\n  responses: Array<{\n    choices: Array<{\n      content: string;\n    }>;\n  }>;\n}\n\n/**\n * Gets multiple completions for a piece of text.\n * @public\n */\nexport async function completeMultipleChoices(\n  options: CompletionMultipleChoicesOptions,\n): Promise<\n  result.Result<{ choices: Array<{ completion: string }> }, RequestError>\n> {\n  return makeSimpleRequest(\n    '/v1beta/completion',\n    getRequestOptions(options),\n    processJSON,\n  );\n}\n\n/**\n * Gets the completion for a piece of text.\n * @public\n */\nexport async function complete(\n  options: CompletionOptions,\n): Promise<result.Result<{ completion: string }, RequestError>> {\n  const res = await makeSimpleRequest(\n    '/v1beta/completion',\n    getRequestOptions(options),\n    processJSON,\n  );\n\n  if (!res.ok) {\n    return res;\n  }\n\n  if (res.value.choices.length > 1) {\n    throw new Error('Got multiple choices without choicesCount');\n  }\n\n  const choice = res.value.choices[0];\n\n  if (!choice) {\n    throw new Error('Expected at least one choice');\n  }\n\n  return result.Ok(choice);\n}\n\n/**\n * Gets a stream of completions for a piece of text.\n * @public\n */\nexport async function completeStream(\n  options: CompletionOptions,\n): Promise<\n  result.Result<AsyncGenerator<{ completion: string }>, RequestError>\n> {\n  return makeStreamingRequest(\n    '/v1beta/completion_streaming',\n    getRequestOptions(options),\n    (json: RawAPIResponse) => {\n      const { choices } = processJSON(json);\n\n      const choice = choices[0];\n\n      if (!choice) {\n        throw new Error('Expected at least one choice');\n      }\n\n      return choice;\n    },\n  );\n}\n\nfunction getRequestOptions(\n  options: CompletionOptions | CompletionMultipleChoicesOptions,\n): Record<string, unknown> {\n  return {\n    model: options.model,\n    parameters: {\n      prompts: [options.prompt],\n      temperature: options.temperature,\n      maxOutputTokens: options.maxOutputTokens,\n      candidateCount:\n        'choicesCount' in options ? options.choicesCount : undefined,\n      ...options.extraParams,\n    },\n  };\n}\n\nfunction processJSON(json: RawAPIResponse): {\n  choices: Array<{ completion: string }>;\n} {\n  if (!json.responses[0]?.choices[0]?.content) {\n    throw new Error('Expected at least one message');\n  }\n\n  return {\n    choices: json.responses[0].choices.map(({ content }) => ({\n      completion: content,\n    })),\n  };\n}\n","import * as result from './result';\nimport { RequestError, makeSimpleRequest } from './request';\n\n/**\n * Available models for text embedding\n * @public\n */\nexport type EmbeddingModel = 'textembedding-gecko';\n\n/**\n * Options for embedding request\n */\nexport interface EmbeddingOptions {\n  /**\n   * The model to embed with\n   */\n  model: EmbeddingModel;\n  /**\n   * The strings to embed, the returned embedding will correspond to the order\n   * of the passed string\n   */\n  content: Array<string>;\n\n  /**\n   * Allows extra model specific parameters. Consult with the documentation\n   */\n  extraParams?: Record<string, unknown>;\n}\n\n/**\n * Embedding vector returned by an embedding request\n * @public\n */\nexport interface Embedding {\n  /**\n   * The embedding vectors corresponding to the words in the input text\n   */\n  values: Array<number>;\n  /**\n   * Indicates if the input text was longer than max allowed tokens and truncated\n   */\n  truncated: boolean;\n}\n\n// non exauhstive\ninterface Response {\n  embeddings: Array<Embedding>;\n}\n\n/**\n * Converts text into numerical vectors\n * @public\n */\nexport async function embed(\n  options: EmbeddingOptions,\n): Promise<result.Result<{ embeddings: Array<Embedding> }, RequestError>> {\n  return makeSimpleRequest(\n    '/v1beta/embedding',\n    {\n      model: options.model,\n      parameters: {\n        content: options.content.map((content) => ({ content })),\n        ...options.extraParams,\n      },\n    },\n    (json: Response): { embeddings: Array<Embedding> } => ({\n      embeddings: json.embeddings.map((embedding) => ({\n        values: embedding.values,\n        truncated: embedding.truncated,\n      })),\n    }),\n  );\n}\n"],"mappings":"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","names":["pushable","options","_pushable","isAsyncIterable","source","processJSON","processJSON","getRequestOptions","processJSON"]}